export const eindeVanDeTussenlaagContent = `
Als je kijkt naar hoe non-developers de afgelopen jaren processen automatiseren, dan gebeurt dat meestal via low-code platforms zoals Make, n8n of Zapier. Of via corporate varianten zoals Power Automate. Je klikt bouwblokken aan elkaar, stelt parameters in per stap en bouwt zo een werkend proces. En wil je er nog een interface omheen? Dan gebruik je Softr, Retool, Appsmith of Power Apps om een simpele app te bouwen.

Dit werkt al jaren uitstekend. Het was de essentie van de "Low-Code Revolutie": mensen die processen snappen maar geen code schrijven, kunnen ineens dingen automatiseren waar eerst developers voor nodig waren.

Maar in dit AI-tijdperk van de afgelopen jaren - en zeker in de komende jaren - wordt die tussenlaag voor veel moderne use-cases steeds minder logisch. Niet omdat low-code "slecht" is, maar omdat het niet meer de snelste, meest flexibele of meest toekomstbestendige route is. Bij Schakel AI slaan wij die laag daarom volledig over. Wij kiezen voor vibecoding: AI-assisted full-code.

En om een misverstand meteen te voorkomen:

**We zeggen niet dat vibecoding beter is dan traditioneel coderen. We zeggen wel dat elke developer AI-assisted coderen zou moeten omarmen.**

Wat we stellen is eenvoudig: vibecoding is in veel situaties een betere keuze dan low-code.

Hier is waarom.

---

## 1. De sweet spot van low-code is grotendeels verdwenen

Low-code ontstond om een reden:

*"Ik kan niet coderen, dus ik gebruik een visuele tool."*

Die redenering wordt steeds minder relevant.

Met de huidige generatie modellen, zoals Claude Opus 4.5, GPT-5.1 en Gemini 3.0, gecombineerd met AI-agents in Replit, Lovable en Cursor, is de drempel om echte code te schrijven nagenoeg verdwenen.

De bottleneck is niet langer *kun je coderen*, maar:

**Kun je logisch denken, processen doorgronden en je intentie duidelijk formuleren?**

En dat is precies wat wij met onze achtergrond in Finance en Business Intelligence al jaren doen.

In Power Automate of n8n zoek je nog steeds door menu's en stel je blokjes in. In Replit zeg je tegen de agent wat je wilt en de code staat er in seconden.

Dat dit niet alleen sneller, maar ook professioneler kan zijn, wordt bevestigd door meerdere onafhankelijke onderzoeken:

- **McKinsey Global Institute** toont aan dat AI-coding 20-45% van ontwikkeltaken kan automatiseren en de productiviteit substantieel verhoogt in software engineering.
- **Stanford AI Index (2024/2025)** laat zien dat generative AI bij developmentteams wereldwijd leidt tot kortere reviewcycli, hogere codekwaliteit en snelle adoptie.
- **Microsoft Research** toont in een gecontroleerd experiment dat developers met Copilot 55,8% sneller zijn dan zonder.
- **Harvard, MIT & Boston University** vonden dat AI-assistentie zorgt voor 12% snellere output en 40% hogere kwaliteit bij kenniswerkers.

Het punt blijft hetzelfde: **AI assisted development is here to stay.**

---

## 2. Eigendom vs. Huur: de vendor-lock-in valkuil

Dit is voor ons een principieel en essentieel punt.

Bouwen in low-code betekent bouwen op gehuurde grond:

- Je zit vast aan licentiemodellen die kunnen stijgen.
- Je zit vast aan connectors die misschien niet doen wat jij wilt.
- Je zit vast in een UI-framework dat je niet kunt aanpassen.

Dit is precies waarom in recente analyses over vibecoding wordt gesteld dat het fundamentele verschil niet "snelheid" is, maar **eigenaarschap over je software**.

Bij vibecoding is dat anders.

Platforms zoals Replit en Lovable bieden weliswaar een geintegreerde alles-in-een ervaring (frontend, backend, database), maar het hoeft niet. Bij Schakel AI bouwen we bewust in een modulaire stack:

- **Vercel** (frontend)
- **Railway** (backend)
- **Supabase** (database)

Alles staat in onze eigen Git-repositories.

Wil je later migreren? Prima. Vind je Replit niet meer de beste vibecoding-tool? Dan stap je over naar Lovable of iets nieuws.

**De code is van ons en van de klant, niet van een platform.**

---

## 3. AI spreekt de taal van code - consistenter dan vaak wordt gedacht

Rond AI-assisted coding bestaan misvattingen: dat de code onbetrouwbaar zou zijn, dat het alleen geschikt is voor prototypes, of dat je meer tijd kwijt bent aan fixes dan aan bouwen. Dat beeld hoort bij de eerste generatie AI-tools.

De realiteit is anders.

Op de onafhankelijke benchmark SWE-bench Verified lossen moderne modellen (zoals GPT-5.1 en Opus) complexe softwareproblemen op, inclusief edge-cases en foutafhandeling.

In de praktijk werkt vibecoding zo: je beschrijft wat het systeem moet doen, de AI genereert een consistente codebasis, en jij bewaakt architectuur, veiligheid en nuance. Het resultaat is geen "AI-demo", maar een solide implementatie die je volledig kunt testen, aanpassen en uitbreiden.

---

## 4. De menselijke maat: architectuur, veiligheid en controle

Betekent dit dat we alles blind overlaten aan de AI? Absoluut niet.

**AI is de motor, maar wij zitten aan het stuur.**

Onze werkwijze combineert de snelheid van AI met de zekerheid van menselijke expertise. De code die door de agent wordt gegenereerd, wordt gecontroleerd en waar nodig geoptimaliseerd door een ervaren developer. AI doet het zware werk (de eerste 80%), waardoor wij ons kunnen richten op de cruciale laatste 20%: security, architectuur, schaalbaarheid en edge-cases.

Zo krijg je de snelheid van een prototype, maar de robuustheid van enterprise software.

---

## Conclusie

Low-code was jarenlang de logische keuze: een brug tussen business en IT, en een manier om zonder programmeerkennis toch software te bouwen.

Maar de sweet spot wordt kleiner. AI-assisted development heeft de oorspronkelijke belofte van low-code - snel bouwen zonder technische diepgang - overgenomen, maar dan met meer controle, flexibiliteit en eigenaarschap.

Bij Schakel AI kiezen we daarom voor vibecoding.

- Non-developers kunnen nu dingen bouwen die eerder onmogelijk waren.
- Developers worden 5x tot 10x productiever.
- En wij bouwen liever aan echte software-assets dan aan oplossingen die vastzitten in andermans omgeving.

**Zo bouwen we robuust, simpel en klaar voor de toekomst.**
`;
